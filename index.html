<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OLX Command Center</title>
    <style>
        /* --- General Layout --- */
        :root { --main-blue: #007bff; --light-blue: #e0eafc; --ai-purple: #563d7c; --gray-bg: #f4f4f5; --light-gray: #e9e9eb; --text-dark: #111; --text-light: #555; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; display: flex; margin: 0; height: 100vh; background-color: var(--gray-bg); font-size: 14px; }
        * { box-sizing: border-box; }

        /* --- Sidebar --- */
        #sidebar { width: 300px; border-right: 1px solid #ccc; height: 100%; display: flex; flex-direction: column; background-color: #fff; }
        .sidebar-header { padding: 8px 12px; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between; align-items: center; }
        .sidebar-header h2 { margin: 0; font-size: 1.2em; color: #333; }
        .sidebar-controls { display: flex; align-items: center; font-size: 12px; }
        .sidebar-controls label { margin-right: 10px; }
        .sidebar-controls button { background: none; border: 1px solid #ccc; cursor: pointer; border-radius: 5px; padding: 5px 8px; }
        #threads-list { flex-grow: 1; overflow-y: auto; }
        
        /* --- Broadcast (Group Message) Section --- */
        #broadcast-section { padding: 10px; border-top: 1px solid #ccc; }
        #broadcast-section textarea { width: 100%; resize: vertical; padding: 8px; border: 1px solid #ccc; border-radius: 5px; margin-bottom: 5px; }
        #broadcast-section button { width: 100%; padding: 10px; background-color: var(--ai-purple); color: white; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; }
        #broadcast-section button:disabled { background-color: #ccc; }

        /* --- Thread Item in Sidebar --- */
        .thread-item { padding: 8px 12px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; align-items: flex-start; }
        .thread-item:hover { background-color: #f0f0f0; }
        .thread-item.active { background-color: var(--light-blue); border-right: 3px solid var(--main-blue); }
        .thread-item input[type="checkbox"] { margin-right: 10px; }
        .thread-item-info { flex-grow: 1; }
        .thread-item-info p, .thread-item-info small { margin: 0; color: var(--text-light); }
        .thread-item-info p { font-weight: 500; color: var(--text-dark); display: flex; justify-content: space-between; align-items: center; }
        .thread-item.unread p { font-weight: bold; }
        .conversation-id-wrapper { display: flex; align-items: center; }
        .badge { background-color: var(--main-blue); color: #fff; border-radius: 50%; min-width: 18px; height: 18px; display: inline-flex; align-items: center; justify-content: center; font-size: 10px; margin-left: 4px; }
        .note-button { background: none; border: 1px solid #ccc; border-radius: 3px; cursor: pointer; padding: 2px 4px; }
        .tag-buttons { display: flex; gap: 4px; }
        .thread-item .tag-buttons { margin-left: 5px; }
        .tag-buttons .tag-btn { width: 20px; height: 20px; border: 1px solid #ccc; border-radius: 3px; background-color: #f8f9fa; cursor: pointer; font-size: 12px; line-height: 18px; text-align: center; padding: 0; }
        .tag-buttons .tag-btn.red { background-color: #f8d7da; }
        .tag-buttons .tag-btn.red.active { background-color: #dc3545; color: #fff; }
        .tag-buttons .tag-btn.blue { background-color: #d1ecf1; }
        .tag-buttons .tag-btn.blue.active { background-color: #0d6efd; color: #fff; }
        .tag-buttons .tag-btn.check.active { background-color: #d4edda; }
        #modal-overlay { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.4); display:flex; align-items:center; justify-content:center; z-index:1000; }
        #modal-overlay.hidden { display:none; }
        #modal { background:#fff; padding:20px; border-radius:5px; width:300px; }
        #modal-body input, #modal-body textarea { width:100%; margin-bottom:10px; }
        #modal .modal-actions { text-align:right; }
        #modal .modal-actions button { margin-left:5px; }
        #back-button, #close-settings-button { margin: 5px; padding: 5px 10px; border: 1px solid #ccc; background: none; border-radius: 5px; cursor: pointer; }
        #back-button { display: none; }

        #chat-header {
            position: sticky;
            top: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.6);
            z-index: 1001;
        }

        #close-chat-button {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%;
            background: var(--main-blue);
            color: #fff;
            cursor: pointer;
            opacity: 0.7;
        }

        #close-chat-button:hover { opacity: 1; }

        /* --- Main Content Area --- */
        #main-content { flex-grow: 1; display: flex; flex-direction: column; height: 100%; }
        #content-area { flex-grow: 1; display: flex; flex-direction: column; }
        .placeholder { text-align: center; color: #888; margin: auto; }
        
        /* --- AI Analyzer Section --- */
        #analyzer-section { padding: 15px; border-bottom: 1px solid #ccc; background-color: #fafafa; }
        #analyzer-section p { margin: 0 0 10px 0; font-weight: bold; }
        .analyzer-input-group { display: flex; }
        #analyzer-input { flex-grow: 1; border: 1px solid #ccc; border-radius: 5px; padding: 8px; }
        #analyzer-button { margin-left: 10px; background-color: var(--ai-purple); color: white; border:none; border-radius:5px; padding: 0 15px; font-weight: bold; cursor: pointer; }
        #analyzer-result { margin-top: 10px; padding: 10px; background-color: #eef; border-radius: 5px; color: #333; }

        /* --- Messages View --- */
        #messages-view { flex-grow: 1; padding: 15px; overflow-y: auto; }
        .message { margin-bottom: 10px; padding: 8px 12px; border-radius: 18px; max-width: 70%; word-wrap: break-word; line-height: 1.4; }
        .message.sent { background-color: var(--main-blue); color: white; align-self: flex-end; }
        .message.received { background-color: var(--light-gray); color: black; align-self: flex-start; }
        #messages-container { display: flex; flex-direction: column; }

        /* --- Reply Area --- */
        #reply-area { border-top: 1px solid #ccc; padding: 8px; display: flex; flex-direction: column; background-color: #f9f9f9; gap: 10px; }
        #reply-area textarea { width: 100%; resize: none; overflow-y: hidden; border-radius: 18px; border: 1px solid #ccc; padding: 10px; font-size: 14px; line-height: 1.4; min-height: 40px; }
        #reply-buttons { display: flex; gap: 10px; }
        #reply-area button { padding: 0 20px; height: 38px; border-radius: 18px; border: none; font-weight: bold; cursor: pointer; transition: background-color 0.2s; white-space: nowrap; }
        #reply-area button#send-button { background-color: var(--main-blue); color: white; }
        #reply-area button#generate-ai-button { background-color: var(--ai-purple); color: white; }
        #reply-area button:disabled { background-color: #ccc; cursor: not-allowed; }

        /* --- Settings View --- */
        #settings-view { padding: 20px; }
        #settings-view h2 { margin-top: 0; }
        #settings-view textarea { width: 100%; height: 200px; resize: vertical; padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        #settings-view button { padding: 10px 20px; background-color: var(--main-blue); color: white; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; margin-top: 10px; }
        #status-message { margin-top: 10px; font-weight: bold; }
        .success { color: green; }
        .error { color: red; }

        /* --- General Helpers --- */
        .hidden { display: none !important; }
        #loader, #messages-loader { text-align: center; padding: 20px; color: #888; }

        /* --- Responsive Layout --- */
        @media (max-width: 600px) {
            body { flex-direction: column; height: 100vh; font-size: 16px; }
            #sidebar, #main-content { width: 100%; height: 100%; }
            #sidebar { border-right: none; border-bottom: none; }
            #back-button { display: block; }
        }

        /* --- Dark Theme --- */
        body.dark {
            --gray-bg: #121212;
            --text-dark: #eee;
            --text-light: #bbb;
            --light-gray: #2c2c2c;
            --main-blue: #2d7bff;
            --ai-purple: #7a4fa3;
            background-color: var(--gray-bg);
            color: var(--text-dark);
            font-family: "Segoe UI", Roboto, sans-serif;
        }

        body.dark #sidebar { background-color: #1e1e1e; border-right: 1px solid #333; }
        body.dark .sidebar-header { border-bottom: 1px solid #333; }
        body.dark .sidebar-header h2 { color: var(--text-dark); }
        body.dark .sidebar-controls button { border-color: #333; color: var(--text-dark); }
        body.dark #broadcast-section { border-top: 1px solid #333; background-color: #1e1e1e; }
        body.dark #broadcast-section textarea { border-color: #333; background-color: #2c2c2c; color: var(--text-dark); }
        body.dark #broadcast-section button { background-color: var(--ai-purple); }
        body.dark .thread-item { border-bottom: 1px solid #333; }
        body.dark .thread-item:hover { background-color: #2c2c2c; }
        body.dark .thread-item.active { background-color: #2d333b; }
        body.dark .thread-item-info p, body.dark .thread-item-info small { color: var(--text-light); }
        body.dark .thread-item-info p { color: var(--text-dark); }
        body.dark .tag-buttons .tag-btn { background-color: #2c2c2c; border-color: #333; color: var(--text-light); }
        body.dark #chat-header { background: rgba(18, 18, 18, 0.6); }
        body.dark #analyzer-section { border-bottom: 1px solid #333; background-color: #1e1e1e; }
        body.dark #analyzer-input { border: 1px solid #333; background-color: #2c2c2c; color: var(--text-dark); }
        body.dark #analyzer-result { background-color: #2d333b; color: var(--text-dark); }
        body.dark #messages-view { background-color: var(--gray-bg); }
        body.dark .message.received { background-color: #2c2c2c; color: var(--text-dark); }
        body.dark #reply-area { border-top: 1px solid #333; background-color: #1e1e1e; }
        body.dark #reply-area textarea { border: 1px solid #333; background-color: #2c2c2c; color: var(--text-dark); }
        body.dark #settings-view { color: var(--text-dark); }
        body.dark #settings-view textarea { border: 1px solid #333; background-color: #2c2c2c; color: var(--text-dark); }
        body.dark #status-message { color: var(--text-dark); }
        body.dark #modal { background: #2c2c2c; color: var(--text-dark); }
    </style>
</head>
<body>

    <!-- SIDEBAR: Списък с разговори и инструменти за групови съобщения -->
    <div id="sidebar">
        <div class="sidebar-header">
            <h2>Разговори</h2>
            <div class="sidebar-controls">
                <label><input type="checkbox" id="select-all-checkbox"> Всички</label>
                <button id="refresh-button">🔄</button>
                <button id="settings-button" style="margin-left: 5px;">⚙️</button>
            </div>
        </div>
        <div id="loader">Зареждам разговори...</div>
        <div id="threads-list"></div>
        <div id="broadcast-section" class="hidden">
            <textarea id="broadcast-message" rows="4" placeholder="Напишете групово съобщение..."></textarea>
            <button id="broadcast-button" disabled>Изпрати на избраните (0)</button>
        </div>
    </div>

    <!-- MAIN CONTENT: Място за показване на чат, настройки и др. -->
    <div id="main-content">
        <div id="content-area">
            <!-- Начален изглед -->
            <div id="placeholder-view" class="placeholder">
                <h1>OLX Command Center</h1>
                <p>Изберете разговор отляво, за да започнете.</p>
            </div>

            <!-- Изглед за чат -->
            <div id="chat-view" class="hidden" style="display: flex; flex-direction: column; height: 100%;">
                <button id="back-button" class="hidden">⬅️ Назад</button>
                <div id="chat-header" class="chat-header">
                    <div id="chat-tags" class="tag-buttons"></div>
                    <button id="close-chat-button" class="hidden">✖</button>
                </div>
                <div id="analyzer-section">
                    <p>AI Анализатор на разговора</p>
                    <div class="analyzer-input-group">
                        <input type="text" id="analyzer-input" placeholder="Напр. 'Какъв е адресът за доставка?'">
                        <button id="analyzer-button">Питай AI</button>
                    </div>
                    <div id="analyzer-result" class="hidden"></div>
                </div>
                <div id="messages-view"></div>
                <div id="reply-area">
                    <textarea id="reply-text" rows="1" placeholder="Напишете отговор..."></textarea>
                    <div id="reply-buttons">
                        <button id="send-button">Изпрати</button>
                        <button id="generate-ai-button" class="ai-button">✨ Генерирай</button>
                    </div>
                </div>
            </div>

            <!-- Изглед за настройки -->
            <div id="settings-view" class="hidden">
                <button id="close-settings-button">⬅️ Назад</button>
                <h2>Настройки на AI Асистента</h2>
                <p>Тук можете да промените системния промпт, който AI използва, за да генерира отговори. Опишете каква роля искате да играе, какъв тон да използва и т.н.</p>
                <textarea id="prompt-textarea"></textarea>
                <label style="display:block;margin-top:10px;">
                    <input type="checkbox" id="auto-reply-checkbox"> Автоматичен AI отговор при ново съобщение
                </label>
                <label style="display:block;margin-top:10px;">
                    Тема:
                    <select id="theme-select">
                        <option value="light">Светла</option>
                        <option value="dark">Тъмна</option>
                    </select>
                </label>
                <button id="save-prompt-button">Запази промпта</button>
                <div id="status-message"></div>
            </div>
        </div>
    </div>

    <div id="modal-overlay" class="hidden">
        <div id="modal">
            <h3 id="modal-title"></h3>
            <div id="modal-body"></div>
            <div class="modal-actions">
                <button id="modal-save">Запази</button>
                <button id="modal-close">Затвори</button>
            </div>
        </div>
    </div>
    <script src="auth.js"></script>
    <script>
        // --- CONFIGURATION ---
        const API_BASE_URL = 'https://olx.radilov-k.workers.dev';
        const AUTH_URL = 'https://www.olx.bg/oauth/authorize?response_type=code&client_id=200383&redirect_uri=https://olx.radilov-k.workers.dev/callback&scope=read+write+v2&state=random_string_12345';
        
        // --- STATE ---
        let currentThreadId = null;
        let autoReplyEnabled = JSON.parse(localStorage.getItem('autoReply') || 'false');
        let theme = localStorage.getItem('theme') || 'light';
        if (theme === 'dark') document.body.classList.add('dark');

        // --- DOM ELEMENTS ---
        const elements = {
            sidebar: document.getElementById('sidebar'),
            loader: document.getElementById('loader'),
            threadsList: document.getElementById('threads-list'),
            selectAllCheckbox: document.getElementById('select-all-checkbox'),
            refreshButton: document.getElementById('refresh-button'),
            settingsButton: document.getElementById('settings-button'),
            broadcastSection: document.getElementById('broadcast-section'),
            broadcastMessage: document.getElementById('broadcast-message'),
            broadcastButton: document.getElementById('broadcast-button'),
            placeholderView: document.getElementById('placeholder-view'),
            chatView: document.getElementById('chat-view'),
            settingsView: document.getElementById('settings-view'),
            closeSettingsButton: document.getElementById('close-settings-button'),
            messagesView: document.getElementById('messages-view'),
            replyText: document.getElementById('reply-text'),
            sendButton: document.getElementById('send-button'),
            generateAiButton: document.getElementById('generate-ai-button'),
            analyzerInput: document.getElementById('analyzer-input'),
            analyzerButton: document.getElementById('analyzer-button'),
            analyzerResult: document.getElementById('analyzer-result'),
            promptTextarea: document.getElementById('prompt-textarea'),
            savePromptButton: document.getElementById('save-prompt-button'),
            statusMessage: document.getElementById('status-message'),
            autoReplyCheckbox: document.getElementById('auto-reply-checkbox'),
            themeSelect: document.getElementById('theme-select'),
            mainContent: document.getElementById('main-content'),
            backButton: document.getElementById('back-button'),
            closeChatButton: document.getElementById('close-chat-button'),
        };

        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', () => {
            fetchThreads();

            if (isMobile()) {
                elements.mainContent.classList.add('hidden');
            }

            elements.refreshButton.addEventListener('click', fetchThreads);
            elements.settingsButton.addEventListener('click', showSettingsView);
            elements.selectAllCheckbox.addEventListener('change', handleSelectAll);
            elements.threadsList.addEventListener('change', e => {
                if (e.target.classList.contains('thread-checkbox')) updateBroadcastCounter();
            });

            elements.sendButton.addEventListener('click', sendMessage);
            elements.generateAiButton.addEventListener('click', generateAiReply);
            elements.analyzerButton.addEventListener('click', analyzeThread);
            elements.broadcastButton.addEventListener('click', sendBroadcastMessage);
            elements.savePromptButton.addEventListener('click', savePrompt);
            elements.closeSettingsButton.addEventListener('click', closeSettingsView);
            elements.backButton.addEventListener('click', showSidebarOnMobile);
            elements.closeChatButton.addEventListener('click', closeChat);
            autoResizeReplyText();
            elements.replyText.addEventListener('input', autoResizeReplyText);

            elements.themeSelect.value = theme;
            elements.themeSelect.addEventListener('change', e => {
                theme = e.target.value;
                document.body.classList.toggle('dark', theme === 'dark');
                localStorage.setItem('theme', theme);
            });
        });

        // --- VIEW MANAGEMENT ---
        function showView(viewToShow) {
            [elements.placeholderView, elements.chatView, elements.settingsView].forEach(view => {
                view.classList.add('hidden');
            });
            viewToShow.classList.remove('hidden');
            if (viewToShow === elements.chatView) {
                elements.closeChatButton.classList.remove('hidden');
            } else {
                elements.closeChatButton.classList.add('hidden');
            }
        }

        function isMobile() {
            return window.innerWidth <= 600;
        }

        function showThreadOnMobile() {
            if (isMobile()) {
                elements.sidebar.classList.add('hidden');
                elements.mainContent.classList.remove('hidden');
                elements.backButton.classList.remove('hidden');
            }
        }

        function showSidebarOnMobile() {
            if (isMobile()) {
                elements.sidebar.classList.remove('hidden');
                elements.mainContent.classList.add('hidden');
                elements.backButton.classList.add('hidden');
                showView(elements.placeholderView);
            }
        }

        function closeChat() {
            currentThreadId = null;
            document.querySelectorAll('.thread-item').forEach(el => el.classList.remove('active'));
            showView(elements.placeholderView);
            showSidebarOnMobile();
        }

        // --- CORE FUNCTIONS ---

        const advertCache = new Map();

        async function getAdvert(id) {
            if (!id) return null;
            if (advertCache.has(id)) return advertCache.get(id);
            const lsKey = `advert_${id}`;
            const cached = localStorage.getItem(lsKey);
            if (cached) {
                const advert = JSON.parse(cached);
                advertCache.set(id, advert);
                return advert;
            }
            try {
                const response = await authorizedFetch(`${API_BASE_URL}/api/adverts/${id}`);
                if (!response.ok) throw new Error('Advert fetch failed');
                const advert = await response.json();
                advertCache.set(id, advert);
                localStorage.setItem(lsKey, JSON.stringify(advert));
                return advert;
            } catch (err) {
                return null; // отказ от API
            }
        }

        async function fetchThreads() {
            elements.loader.classList.remove('hidden');
            elements.threadsList.innerHTML = '';
            try {
                const response = await authorizedFetch(`${API_BASE_URL}/api/threads`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`${errorData.error} <a href="${AUTH_URL}">Оторизирайте се отново</a>.`);
                }
                const threads = await response.json();
                if (!threads || threads.length === 0) {
                    elements.threadsList.innerHTML = '<p style="padding: 15px;">Няма намерени разговори.</p>';
                    return;
                }

                for (const thread of threads) {
                    const meta = getThreadMeta(thread.id);
                    if (thread.advert_id) {
                        try {
                            const advert = await getAdvert(thread.advert_id);
                            if (advert && advert.data) {
                                meta.advertTitle = advert.data.title || meta.advertTitle;
                                meta.advertCreatedAt = advert.data.created_at || meta.advertCreatedAt;
                            } else {
                                meta.advertTitle = meta.advertTitle || '(невалидна обява)';
                            }
                        } catch (err) {
                            meta.advertTitle = meta.advertTitle || '(невалидна обява)';
                        }
                        saveThreadMeta(thread.id, meta);
                    }

                    const threadElement = document.createElement('div');
                    threadElement.className = 'thread-item';
                    threadElement.dataset.threadId = thread.id;

                    const lastDateRaw = meta.lastDate || thread.last_message_date || thread.last_message?.created_at || thread.last_message?.date || thread.updated_at;
                    const isRead = thread.unread_count === 0 || (meta.lastRead && new Date(meta.lastRead) >= new Date(lastDateRaw));
                    const lastDate = formatDate(lastDateRaw);
                    if (!isRead) threadElement.classList.add('unread');
                    if (autoReplyEnabled && !isRead && meta.lastAutoReply !== lastDateRaw) {
                        autoReply(thread.id);
                        meta.lastAutoReply = lastDateRaw;
                        saveThreadMeta(thread.id, meta);
                    }

                    const conversationId = thread.id;
                    const advertTitle = meta.advertTitle || '';
                    const displayName = meta.contactName || thread.contact_name || conversationId;
                    const shortTitle = getFirstWords(advertTitle, 2);

                    threadElement.innerHTML = `
                        <input type="checkbox" class="thread-checkbox" data-id="${thread.id}" name="thread-checkbox-${thread.id}">
                        <div class="thread-item-info">
                            <p><span class="conversation-id-wrapper"><span class="conversation-id">${displayName}</span>${thread.unread_count > 0 ? `<span class="badge">${thread.unread_count}</span>` : ''}</span><span class="tag-buttons">${createTagButtons(meta)}</span></p>
                            <small class="advert-title">${shortTitle}</small>
                            <small class="last-date">Последно: ${lastDate}</small>
                        </div>
                    `;

                    const info = threadElement.querySelector('.thread-item-info');
                    const tagContainer = threadElement.querySelector('.tag-buttons');
                    attachTagButtonEvents(tagContainer, meta, thread.id);
                    info.addEventListener('click', () => {
                        document.querySelectorAll('.thread-item').forEach(el => el.classList.remove('active'));
                        threadElement.classList.add('active');
                        displayMessages(thread.id);
                        showThreadOnMobile();
                    });

                    refreshThreadDetails(thread.id, threadElement, meta);

                    elements.threadsList.appendChild(threadElement);
                }
            } catch (error) {
                elements.threadsList.innerHTML = `<p style="color: red; padding: 15px;">${error.message}</p>`;
            } finally {
                elements.loader.classList.add('hidden');
            }
        }

        async function refreshThreadDetails(id, threadElement, meta) {
            const advertEl = threadElement.querySelector('.advert-title');
            try {
                const response = await authorizedFetch(`${API_BASE_URL}/api/threads/${id}/details`);
                if (!response.ok) throw new Error('fetch failed');
                const data = await response.json();
                meta.advertTitle = data.advertTitle || '';
                meta.lastDate = data.lastMessageDate || meta.lastDate;
                saveThreadMeta(id, meta);
                advertEl.textContent = getFirstWords(meta.advertTitle, 2);
                const dateEl = threadElement.querySelector('.last-date');
                if (dateEl) dateEl.textContent = `Последно: ${formatDate(meta.lastDate)}`;
            } catch (err) {
                advertEl.textContent = getFirstWords(meta.advertTitle, 2) || advertEl.textContent;
            }
        }

        async function displayMessages(threadId) {
            currentThreadId = threadId;
            showView(elements.chatView);
            renderChatTags(threadId);
            elements.messagesView.innerHTML = '<div id="messages-loader">Зареждам съобщенията...</div>';
            elements.analyzerResult.classList.add('hidden');
            elements.analyzerInput.value = '';

            try {
                const response = await authorizedFetch(`${API_BASE_URL}/api/threads/${threadId}/messages`);
                if (!response.ok) throw new Error('Неуспешно зареждане на съобщенията.');
                
                const messages = await response.json();
                elements.messagesView.innerHTML = '<div id="messages-container"></div>';
                const container = document.getElementById('messages-container');

                if (!messages || messages.length === 0) {
                    container.innerHTML = '<p>Няма съобщения в този разговор.</p>';
                } else {
                    messages.forEach(msg => {
                        const msgElement = document.createElement('div');
                        msgElement.className = `message ${msg.type}`;
                        msgElement.textContent = msg.text;
                        container.appendChild(msgElement);
                    });
                    elements.messagesView.scrollTop = elements.messagesView.scrollHeight;

                    const meta = getThreadMeta(threadId);
                    const lastMsg = messages[messages.length - 1];
                    meta.lastDate = lastMsg?.created_at || lastMsg?.date || meta.lastDate;
                    const clientMsg = messages.find(m => m.type === 'received') ||
                        messages.find(m => m.type !== 'sent') ||
                        messages[0];
                    if (clientMsg) {
                        meta.contactName = clientMsg.user_name || clientMsg.user?.name || clientMsg.sender?.name || meta.contactName;
                    }
                    saveThreadMeta(threadId, meta);
                    renderChatTags(threadId);
                    const threadEl = document.querySelector(`.thread-item[data-thread-id="${threadId}"]`);
                    if (threadEl) {
                        const dateEl = threadEl.querySelector('.last-date');
                        if (dateEl) dateEl.textContent = `Последно: ${formatDate(meta.lastDate)}`;
                        const nameEl = threadEl.querySelector('.conversation-id');
                        if (nameEl) nameEl.textContent = meta.contactName || threadId;
                    }
                    markThreadRead(threadId);
                }
            } catch (error) {
                elements.messagesView.innerHTML = `<p class="error">${error.message}</p>`;
            }
        }

        function autoResizeReplyText() {
            elements.replyText.style.height = 'auto';
            const minHeight = parseInt(getComputedStyle(elements.replyText).minHeight) || 0;
            elements.replyText.style.height = Math.max(elements.replyText.scrollHeight, minHeight) + 'px';
        }

        function markThreadRead(threadId) {
            const threadEl = document.querySelector(`.thread-item[data-thread-id="${threadId}"]`);
            if (threadEl) {
                threadEl.classList.remove('unread');
                const badge = threadEl.querySelector('.badge');
                if (badge) badge.remove();
            }
            const meta = getThreadMeta(threadId);
            meta.lastRead = new Date().toISOString();
            saveThreadMeta(threadId, meta);
            authorizedFetch(`${API_BASE_URL}/api/threads/${threadId}/mark-read`, { method: 'POST', keepalive: true })
                .catch(err => console.warn('Неуспешно маркиране на прочетено', err));
        }

        async function sendMessage() {
            if (!currentThreadId) return;
            const text = elements.replyText.value.trim();
            if (!text) return;

            markThreadRead(currentThreadId);

            elements.sendButton.disabled = true;
            elements.sendButton.textContent = '...';

            try {
                const response = await authorizedFetch(`${API_BASE_URL}/api/threads/${currentThreadId}/send-message`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text })
                });
                if (!response.ok) throw new Error((await response.json()).error);

                elements.replyText.value = '';
                autoResizeReplyText();
                setTimeout(() => displayMessages(currentThreadId), 1000);
            } catch (error) {
                alert(`Грешка при изпращане: ${error.message}`);
            } finally {
                elements.sendButton.disabled = false;
                elements.sendButton.textContent = 'Изпрати';
            }
        }

        async function generateAiReply() {
            if (!currentThreadId) return;
            setButtonLoading(elements.generateAiButton, true, 'Мисли...');
            elements.replyText.value = 'AI генерира отговор, моля изчакайте...';
            autoResizeReplyText();

            try {
                const response = await authorizedFetch(`${API_BASE_URL}/api/generate-reply`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ threadId: currentThreadId })
                });
                if (!response.ok) throw new Error((await response.json()).error);
                
                const data = await response.json();
                elements.replyText.value = data.reply;
                autoResizeReplyText();
            } catch (error) {
                elements.replyText.value = `Грешка при генериране: ${error.message}`;
                autoResizeReplyText();
            } finally {
                setButtonLoading(elements.generateAiButton, false, '✨ Генерирай');
            }
        }

        async function autoReply(threadId) {
            try {
                const genRes = await authorizedFetch(`${API_BASE_URL}/api/generate-reply`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ threadId })
                });
                const genData = await genRes.json();
                if (!genRes.ok) throw new Error(genData.error);
                await authorizedFetch(`${API_BASE_URL}/api/threads/${threadId}/send-message`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: genData.reply })
                });
            } catch (err) {
                console.error('Автоматичният отговор се провали:', err);
            }
        }

        async function analyzeThread() {
            if (!currentThreadId) return;
            const question = elements.analyzerInput.value.trim();
            if (!question) return alert('Моля, въведете въпрос.');

            setButtonLoading(elements.analyzerButton, true, '...');
            elements.analyzerResult.classList.remove('hidden');
            elements.analyzerResult.textContent = 'Анализирам...';

            try {
                const response = await authorizedFetch(`${API_BASE_URL}/api/analyze-thread`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ threadId: currentThreadId, question })
                });
                if (!response.ok) throw new Error((await response.json()).error);

                const data = await response.json();
                elements.analyzerResult.textContent = data.answer;
            } catch (error) {
                elements.analyzerResult.textContent = `Грешка: ${error.message}`;
            } finally {
                setButtonLoading(elements.analyzerButton, false, 'Питай AI');
            }
        }

        // --- BROADCAST FUNCTIONS ---
        function handleSelectAll() {
            const isChecked = elements.selectAllCheckbox.checked;
            document.querySelectorAll('.thread-checkbox').forEach(cb => cb.checked = isChecked);
            updateBroadcastCounter();
        }

        function updateBroadcastCounter() {
            const selectedCount = elements.threadsList.querySelectorAll('.thread-checkbox:checked').length;
            elements.broadcastSection.classList.toggle('hidden', selectedCount === 0);
            elements.broadcastButton.disabled = selectedCount === 0;
            elements.broadcastButton.textContent = `Изпрати на избраните (${selectedCount})`;
        }

        async function sendBroadcastMessage() {
            const message = elements.broadcastMessage.value.trim();
            if (!message) return alert('Моля, въведете съобщение за групово изпращане.');
            
            const selectedIds = Array.from(document.querySelectorAll('.thread-checkbox:checked')).map(cb => cb.dataset.id);
            if (selectedIds.length === 0) return;

            if (!confirm(`Сигурни ли сте, че искате да изпратите съобщение до ${selectedIds.length} потребители?`)) return;

            setButtonLoading(elements.broadcastButton, true, 'Изпращам...');
            try {
                const response = await authorizedFetch(`${API_BASE_URL}/api/broadcast`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ threadIds: selectedIds, text: message })
                });
                if (!response.ok) throw new Error((await response.json()).error);

                const data = await response.json();
                alert(`Съобщението е изпратено успешно до ${data.sentCount} от ${selectedIds.length} потребители.`);
                elements.broadcastMessage.value = '';
            } catch (error) {
                alert(`Грешка при групово изпращане: ${error.message}`);
            } finally {
                setButtonLoading(elements.broadcastButton, false, `Изпрати на избраните (${selectedIds.length})`);
            }
        }

        // --- TAG BUTTONS FUNCTIONS ---
        function createTagButtons(meta = {}) {
            return `
                <button class="tag-btn red ${meta.redMark ? 'active' : ''}" title="Червено"></button>
                <button class="tag-btn blue ${meta.blueMark ? 'active' : ''}" title="Синьо"></button>
                <button class="tag-btn check ${meta.checked ? 'active' : ''}" title="Отметка">${meta.checked ? '✓' : ''}</button>
                <button class="tag-btn info" title="Данни">i</button>
                <button class="tag-btn note" title="Бележка">@</button>
            `;
        }

        async function sendAutoMessage(threadId, text) {
            try {
                markThreadRead(threadId);
                await authorizedFetch(`${API_BASE_URL}/api/threads/${threadId}/send-message`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text })
                });
                if (currentThreadId === threadId) {
                    setTimeout(() => displayMessages(threadId), 1000);
                }
            } catch (err) {
                console.warn('Неуспешно изпращане на автоматично съобщение', err);
            }
        }

        function attachTagButtonEvents(container, meta, threadId) {
            const redBtn = container.querySelector('.red');
            const blueBtn = container.querySelector('.blue');
            const checkBtn = container.querySelector('.check');
            const infoBtn = container.querySelector('.info');
            const noteBtn = container.querySelector('.note');

            redBtn.addEventListener('click', e => {
                e.stopPropagation();
                meta.redMark = !meta.redMark;
                saveThreadMeta(threadId, meta);
                updateThreadTagButtons(threadId);
            });

            blueBtn.addEventListener('click', e => {
                e.stopPropagation();
                meta.blueMark = !meta.blueMark;
                saveThreadMeta(threadId, meta);
                updateThreadTagButtons(threadId);
            });

            checkBtn.addEventListener('click', async e => {
                e.stopPropagation();
                meta.checked = !meta.checked;
                saveThreadMeta(threadId, meta);
                updateThreadTagButtons(threadId);
                if (meta.checked) {
                    await sendAutoMessage(threadId, 'Изпратено');
                }
            });

            infoBtn.addEventListener('click', e => {
                e.stopPropagation();
                openInfoModal(threadId);
            });

            noteBtn.addEventListener('click', e => {
                e.stopPropagation();
                openNoteModal(threadId);
            });
        }

        function updateThreadTagButtons(threadId) {
            const meta = getThreadMeta(threadId);
            const threadEl = document.querySelector(`.thread-item[data-thread-id="${threadId}"]`);
            if (threadEl) {
                const tagContainer = threadEl.querySelector('.tag-buttons');
                if (tagContainer) {
                    tagContainer.innerHTML = createTagButtons(meta);
                    attachTagButtonEvents(tagContainer, meta, threadId);
                }
            }
            if (currentThreadId === threadId) {
                renderChatTags(threadId);
            }
        }

        function renderChatTags(threadId) {
            const container = document.getElementById('chat-tags');
            if (!container) return;
            const meta = getThreadMeta(threadId);
            container.innerHTML = createTagButtons(meta);
            attachTagButtonEvents(container, meta, threadId);
        }

        async function openInfoModal(threadId) {
            const meta = getThreadMeta(threadId);
            let info = meta.deliveryInfo || {};
            if (!info.name && !info.phone && !info.address) {
                try {
                    const response = await authorizedFetch(`${API_BASE_URL}/api/analyze-thread`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ threadId, question: 'Извлечи имената, телефон и адреса за доставка. Формат: Name: <...>; Phone: <...>; Address: <...>' })
                    });
                    if (response.ok) {
                        const data = await response.json();
                        const answer = data.answer || '';
                        const nameMatch = answer.match(/Name[:\-]?\s*(.*)/i);
                        const phoneMatch = answer.match(/Phone[:\-]?\s*(.*)/i);
                        const addressMatch = answer.match(/Address[:\-]?\s*(.*)/i);
                        info = {
                            name: nameMatch ? nameMatch[1].trim() : '',
                            phone: phoneMatch ? phoneMatch[1].trim() : '',
                            address: addressMatch ? addressMatch[1].trim() : ''
                        };
                    }
                } catch (e) { }
            }
            showModal('Данни за доставка', `
                <label>Имена:<input type="text" id="info-name" value="${info.name || ''}"></label>
                <label>Телефон:<input type="text" id="info-phone" value="${info.phone || ''}"></label>
                <label>Адрес:<textarea id="info-address" rows="3">${info.address || ''}</textarea></label>
            `, () => {
                meta.deliveryInfo = {
                    name: document.getElementById('info-name').value.trim(),
                    phone: document.getElementById('info-phone').value.trim(),
                    address: document.getElementById('info-address').value.trim()
                };
                const nameForDisplay = getFirstWords(meta.deliveryInfo.name, 2);
                if (nameForDisplay) meta.contactName = nameForDisplay;
                saveThreadMeta(threadId, meta);
                updateThreadTagButtons(threadId);
                const threadEl = document.querySelector(`.thread-item[data-thread-id="${threadId}"]`);
                if (threadEl) {
                    const nameEl = threadEl.querySelector('.conversation-id');
                    if (nameEl) nameEl.textContent = meta.contactName || threadId;
                }
            });
        }

        function openNoteModal(threadId) {
            const meta = getThreadMeta(threadId);
            showModal('Бележка', `
                <textarea id="note-text" rows="4" placeholder="Бележка...">${meta.note || ''}</textarea>
            `, () => {
                meta.note = document.getElementById('note-text').value.trim();
                saveThreadMeta(threadId, meta);
                updateThreadTagButtons(threadId);
            });
        }

        function showModal(title, bodyHtml, onSave) {
            const overlay = document.getElementById('modal-overlay');
            document.getElementById('modal-title').textContent = title;
            const body = document.getElementById('modal-body');
            body.innerHTML = bodyHtml;
            overlay.classList.remove('hidden');
            document.getElementById('modal-save').onclick = () => {
                onSave();
                overlay.classList.add('hidden');
            };
            document.getElementById('modal-close').onclick = () => overlay.classList.add('hidden');
        }

        // --- SETTINGS FUNCTIONS ---
        async function showSettingsView() {
            showView(elements.settingsView);
            showThreadOnMobile();
            elements.statusMessage.textContent = '';
            elements.promptTextarea.value = 'Зареждам текущия промпт...';
            elements.autoReplyCheckbox.checked = autoReplyEnabled;
            elements.themeSelect.value = theme;
            try {
                const response = await authorizedFetch(`${API_BASE_URL}/api/prompt`);
                if (!response.ok) throw new Error((await response.json()).error);
                const data = await response.json();
                elements.promptTextarea.value = data.prompt || '';
            } catch (error) {
                elements.promptTextarea.value = `Грешка при зареждане: ${error.message}`;
            }
        }

        function closeSettingsView() {
            if (isMobile()) {
                showSidebarOnMobile();
            } else {
                showView(currentThreadId ? elements.chatView : elements.placeholderView);
            }
        }

        async function savePrompt() {
            const newPrompt = elements.promptTextarea.value;
            autoReplyEnabled = elements.autoReplyCheckbox.checked;
            setButtonLoading(elements.savePromptButton, true, 'Запазвам...');
            showStatusMessage('Запазвам...');
            try {
                const response = await authorizedFetch(`${API_BASE_URL}/api/prompt`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: newPrompt })
                });
                if (!response.ok) throw new Error((await response.json()).error);
                localStorage.setItem('autoReply', JSON.stringify(autoReplyEnabled));
                showStatusMessage('Настройките са запазени успешно!', 'success');
            } catch (error) {
                showStatusMessage(`Грешка: ${error.message}`, 'error');
            } finally {
                setButtonLoading(elements.savePromptButton, false, 'Запази промпта');
            }
        }

        // --- HELPER FUNCTIONS ---
        function getThreadMeta(id) {
            return JSON.parse(localStorage.getItem(`thread_meta_${id}`) || '{}');
        }

        function saveThreadMeta(id, data) {
            localStorage.setItem(`thread_meta_${id}`, JSON.stringify(data));
        }

        function getFirstWords(text, count) {
            return (text || '').split(/\s+/).slice(0, count).join(' ');
        }

        function formatDate(dateStr) {
            if (!dateStr) return '---';
            const d = new Date(dateStr);
            if (isNaN(d)) return '---';
            const datePart = d.toLocaleDateString('bg-BG', { day: '2-digit', month: '2-digit' });
            const timePart = d.toLocaleTimeString('bg-BG', { hour: '2-digit', minute: '2-digit' });
            return `${datePart} ${timePart}`;
        }

        function setButtonLoading(button, isLoading, loadingText) {
            button.disabled = isLoading;
            if (isLoading) {
                button.dataset.originalText = button.textContent;
                button.textContent = loadingText;
            } else {
                button.textContent = button.dataset.originalText || 'Submit';
            }
        }

        function showStatusMessage(message, type = '') {
            elements.statusMessage.textContent = message;
            elements.statusMessage.className = `status-message ${type}`;
        }

    </script>
</body>
</html>
